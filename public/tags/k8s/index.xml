<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>K8S on 無面者小站</title>
    <link>https://alextrinityblock.github.io/blog/public/tags/k8s/</link>
    <description>Recent content in K8S on 無面者小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hant</language>
    <lastBuildDate>Fri, 02 Feb 2024 11:00:44 +0800</lastBuildDate><atom:link href="https://alextrinityblock.github.io/blog/public/tags/k8s/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K8S基本操作-22-K8S的Secret</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-22/</link>
      <pubDate>Fri, 02 Feb 2024 11:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-22/</guid>
      <description>命令建立 Secret 直接採用指令來輸入 Secret 的方法: kubectl create secret generic db-secret --from-literal=DB_Host=sql01 --from-literal=DB_User=root --from-literal=DB_Password=password123 YAML 儲存 Secret 將 Secret 轉換成 YAML 編輯: kubectl create secret generic db-secret --from-literal=DB_Host=sql01 --from-literal=DB_User=root --from-literal=DB_Password=password123 --dry-run=client -o yaml &amp;gt; db-secret.yaml 可以看到 Base64 編碼後的 Secret (防止一眼被人</description>
    </item>
    
    <item>
      <title>K8S基本操作-23-Exec 執行 Pod 中的指令</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-23/</link>
      <pubDate>Fri, 02 Feb 2024 11:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-23/</guid>
      <description>命令建立 Secret 假定我們的 Pod 稱為 app 。 例如，以下的的指令用來直接看 Pod 中的 Log (當然，這不是好方法，但在一切裝置好之前，也許會用上): kubectl exec -it app cat /log/app.log 或者用</description>
    </item>
    
    <item>
      <title>K8S基本操作-24-關於1個Pod中的2個容器共用1個Volume</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-24/</link>
      <pubDate>Fri, 02 Feb 2024 11:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-24/</guid>
      <description>關於1個Pod中的2個容器共用1個Volume 以下這個YAML中存在1個 Pod app 此 Pod 中有兩個容器app與sidecar。 接著我們注意到以下兩個容</description>
    </item>
    
    <item>
      <title>K8S基本操作-21-K8S的YAML的環境變數與Config Map</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-21/</link>
      <pubDate>Fri, 02 Feb 2024 10:38:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-21/</guid>
      <description>環境變數 我們可以採用以下方式設置環境變數: apiVersion: v1 kind: Pod metadata: labels: name: webapp-color name: webapp-color namespace: default spec: containers: - env: - name: APP_COLOR value: pink image: kodekloud/webapp-color imagePullPolicy: Always name: webapp-color 其中的這一段就是了: - env: - name: APP_COLOR value: pink Config Map 以下是</description>
    </item>
    
    <item>
      <title>K8S基本操作-20-K8S的YAML的 Command 對 Dockerfile 的 Entrypoint 覆蓋</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-20/</link>
      <pubDate>Thu, 01 Feb 2024 10:38:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-20/</guid>
      <description>如果 Dockerfile 跟 K8S 的 YAML 配置的 Entrypoint 與 Command 不一樣呢? 實際上執行的指令會是哪一種? FROMpython:3.6-alpineRUN pip install flaskCOPY . /opt/EXPOSE8080WORKDIR/optENTRYPOINT [&amp;#34;python&amp;#34;, &amp;#34;app.py&amp;#34;]CMD [&amp;#34;--color&amp;#34;, &amp;#34;red&amp;#34;]apiVersion: v1 kind: Pod metadata: name: webapp-green labels: name: webapp-green spec: containers: - name: simple-webapp image: kodekloud/webapp-color command: [&amp;#34;python&amp;#34;, &amp;#34;app.py&amp;#34;] args: [&amp;#34;--color&amp;#34;, &amp;#34;pink&amp;#34;] 最後會以 K8S 的</description>
    </item>
    
    <item>
      <title>K8S基本操作-19-K8S的 Rolling Update與 Recreate </title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-19/</link>
      <pubDate>Tue, 30 Jan 2024 10:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-19/</guid>
      <description>我們觀察以下的 Deployment: apiVersion: apps/v1 kind: Deployment metadata: annotations: deployment.kubernetes.io/revision: &amp;#34;1&amp;#34; creationTimestamp: &amp;#34;2024-02-01T01:17:43Z&amp;#34; generation: 1 name: frontend namespace: default resourceVersion: &amp;#34;1023&amp;#34; uid: 2933b6b7-59b7-412f-b806-8b80a593f61f spec: minReadySeconds: 20 progressDeadlineSeconds: 600 replicas: 4 revisionHistoryLimit: 10 selector: matchLabels: name: webapp strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: creationTimestamp: null labels: name: webapp spec: containers: - image: kodekloud/webapp-color:v1 imagePullPolicy: IfNotPresent name: simple-webapp ports: - containerPort: 8080 protocol:</description>
    </item>
    
    <item>
      <title>K8S基本操作-18-K8S讀取Log</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-18/</link>
      <pubDate>Mon, 29 Jan 2024 17:40:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-18/</guid>
      <description>檢查 Log 只要採用以下方式即可查看 Log 了。 kubectl logs &amp;lt;Pod名稱&amp;gt;</description>
    </item>
    
    <item>
      <title>K8S基本操作-17-安裝Metrics Server</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-17/</link>
      <pubDate>Mon, 29 Jan 2024 17:10:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-17/</guid>
      <description>Metrics Server 可以監控 K8S 的 Cluster 上的每個 Node 的 CPU, RAM 等使用。 安裝 最簡單的方式是參照以下網址，直接一行指令安裝: https://github.com/kubernetes-sigs/metrics-server kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml 使用 可以查看 Node 的 CPU 與 RAM 使用率。 kubectl top node 輸</description>
    </item>
    
    <item>
      <title>K8S基本操作-16-手動自行建設Scheduler</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-16/</link>
      <pubDate>Mon, 29 Jan 2024 16:10:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-16/</guid>
      <description>檢查預設的 Scheduler Scheduler 是個 Pod ，位於 kube-system 這個 namespace。 用以下指令查看 Scheduler: kubectl get pod -n kube-system 設置 Service Account 與 Cluster Role 設置如下: ServiceAccount: my-scheduler (kube-system namespace) ClusterRoleBinding: my-scheduler-as-kube-scheduler ClusterRoleBinding: my-scheduler-as-volume-scheduler 同時建立 Config Map 與 Depl</description>
    </item>
    
    <item>
      <title>K8S基本操作-15-ServiceAccount 和 ClusterRoleBinding</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-15/</link>
      <pubDate>Mon, 29 Jan 2024 16:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-15/</guid>
      <description>ServiceAccount 和 ClusterRoleBinding ServiceAccount（服務帳戶） ServiceAccount（服務帳戶） 是一種 Kubernetes 資源，用於為 Pod 提供身份。Pod 可以使用 ServiceAccount 來訪問</description>
    </item>
    
    <item>
      <title>K8S基本操作-14-Static pods</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-14/</link>
      <pubDate>Mon, 29 Jan 2024 11:10:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-14/</guid>
      <description>Static pods 在 Kubernetes 中，Static Pod 是一種特殊的 Pod，它不像一般的 Pod 由 Deployment 或 DaemonSet 等控制器管理，而是直接由特定節點上的 kubelet 进程管理。Static Pod 的主要特點</description>
    </item>
    
    <item>
      <title>K8S基本操作-13-Daemonsets</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-13/</link>
      <pubDate>Mon, 29 Jan 2024 10:10:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-13/</guid>
      <description>Daemonsets 這類程式常駐於 Node 上，類似程式的守護進程。 可用以下指令檢查所有 Namespace 的 Daemonsets: kubectl get daemonsets --all-namespace 運行叢集守護進程，例如日誌收集、監控、網路代理程式等。 在所有節點</description>
    </item>
    
    <item>
      <title>K8S基本操作-12-Resource limits</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-12/</link>
      <pubDate>Mon, 29 Jan 2024 10:05:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-12/</guid>
      <description>Resource limits 資源限制 我們可以設置一個 Deployment 最少需要多少資源，與最多消耗多少資源。 具體的用法是在 containers 裏頭寫下 requests 與 limits 項目。 官方的範例: --- apiVersion: v1 kind: Pod metadata: name: frontend spec: containers: - name:</description>
    </item>
    
    <item>
      <title>K8S基本操作-11-Node Affinitty</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-11/</link>
      <pubDate>Mon, 29 Jan 2024 10:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-11/</guid>
      <description>Node Affinitty 在 Kubernetes 中，Node affinity（節點親和性）是一種用於控制 Pod 調度到哪些節點上的機制。它允許您根據節點的屬性和標籤，指定 Pod 應該调度到哪些</description>
    </item>
    
    <item>
      <title>K8S基本操作-10-Taints AND Tolerations</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-10/</link>
      <pubDate>Mon, 29 Jan 2024 08:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-10/</guid>
      <description>Taints AND Tolerations 在 Kubernetes 中，Taints 和 Tolerations 是一種用於控制 Pod 調度到哪些節點上的機制。 Taints Taint 是一種附加到節點上的鍵值對。它表示該節點不適合運行具有特定容忍度（</description>
    </item>
    
    <item>
      <title>K8S基本操作-09-Labels and Selectors</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-09/</link>
      <pubDate>Sun, 28 Jan 2024 08:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-09/</guid>
      <description>Labels and Selectors Labels 是附加到 Kubernetes 對象（例如 Pod、Deployment、Service 等）上的鍵值對。它們可以用來對對象進行分類和標識，以便於管理和查找。</description>
    </item>
    
    <item>
      <title>K8S基本操作-08-Scheduling</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-08/</link>
      <pubDate>Fri, 26 Jan 2024 08:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-08/</guid>
      <description>Kube-scheduler kube-scheduler 負責監視新創建的或尚未調度（unscheduled）的 Pod，並選擇一個最佳節點來運行這些 Pod。由於 Pod 中的容器和 Pod 本身可能有不同的要求</description>
    </item>
    
    <item>
      <title>K8S基本操作-07-Ubuntu安裝K8S</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-07/</link>
      <pubDate>Tue, 21 Nov 2023 08:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-07/</guid>
      <description>MicroK8S Ubuntu 官方提供了一個 snap 套件可以超快的安裝 K8S ， 稱為 MicroK8S。 sudo snap install microk8s --classic --channel=1.28 sudo usermod -a -G microk8s $USER sudo chown -f -R $USER ~/.kube su - $USER 安裝後檢查狀態是否安裝完成 microk8s status --wait-ready 使</description>
    </item>
    
    <item>
      <title>K8S基本操作-06-imperative指令</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-06/</link>
      <pubDate>Sun, 19 Nov 2023 18:56:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-06/</guid>
      <description>Imperative imperative command 指令式命令，例如詳細描述每個需要的步驟。 Declarative command 宣告式命令，僅需要描述期待，實現則由程式自行決定。 如 kubectl run nginx-pod --image=nginx:alpine 就屬於 imperative command。</description>
    </item>
    
    <item>
      <title>K8S基本操作-05-Service基本使用</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-05/</link>
      <pubDate>Sun, 19 Nov 2023 18:25:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-05/</guid>
      <description>列出 services kubectl get services 結果如下 controlplane ~ ➜ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.43.0.1 &amp;lt;none&amp;gt; 443/TCP 13m kubernetes 的 ClusterIP 是 K8S 預設的服務。 顯示 service 的細部內容 kubectl describe service kubernetes 結果如下。 controlplane ~ ➜ kubectl describe service kubernetes Name: kubernetes Namespace: default Labels: component=apiserver provider=kubernetes</description>
    </item>
    
    <item>
      <title>K8S基本操作-04-namespace基本使用</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-04/</link>
      <pubDate>Sun, 19 Nov 2023 17:50:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-04/</guid>
      <description>列出 namespaces kubectl get namespaces 列出某 namespaces 裏頭的 pods 例如我們要取得 research namespaces 裏頭的 pod。 kubectl -n research get pods 算出某個 namespaces 裏頭的 pods 數量 kubectl -n research get pods --no-headers | wc -l 手動在某 namespaces 裏頭啟動 pod kubectl -n finance run redis</description>
    </item>
    
    <item>
      <title>K8S基本操作-03-Deployment基本使用</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-03/</link>
      <pubDate>Sun, 19 Nov 2023 17:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-03/</guid>
      <description>取得當前有多少 Deployments kubectl get deployments 檢查 Deployments kubectl describe deployment frontend-deployment 用 YAML 執行一個 Deployment 記得 kind: Deployment 開頭要大寫 kubectl apply -f deployment-definition-1.yaml 閱讀 Deployment 官方文檔 kubectl explain deployment</description>
    </item>
    
    <item>
      <title>K8S基本操作-02-ReplicaSet基本使用</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-02/</link>
      <pubDate>Sun, 19 Nov 2023 12:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-02/</guid>
      <description>本篇筆記主要談論 ReplicaSet 的基本操作。 列出所有 ReplicaSet kubectl get replicasets 顯示結果類似 NAME DESIRED CURRENT READY AGE new-replica-set 4 4 0 15s 檢查 ReplicaSet 中 pod 的內容 kubectl describe replicaset 檢查 API 版本 kubectl api-resources | grep replicaset 這個 API 版本有可能是第</description>
    </item>
    
    <item>
      <title>K8S基本操作-01-建立與管理Pod</title>
      <link>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-01/</link>
      <pubDate>Sun, 19 Nov 2023 10:00:44 +0800</pubDate>
      
      <guid>https://alextrinityblock.github.io/blog/public/post/k8s/k8s%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-01/</guid>
      <description>本篇筆記主要談論 kubectl 的基本操作。 列出 default namespace 的 pods kubectl get pods 或者 kubectl get pods -n default 手動運作一個 Nginx 的 pod kubectl run nginx --image=nginx 確認 pod 使用哪個 image 用以下指令顯示 pod 完整細節。 例如我們的</description>
    </item>
    
  </channel>
</rss>
