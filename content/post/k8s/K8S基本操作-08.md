---
title: "K8S基本操作-08-Scheduling"
date: 2024-01-26T08:00:44+08:00
draft: false
featured_image: "/k8s.png"
tags: ["K8S"]
---

# Kube-scheduler

kube-scheduler 負責監視新創建的或尚未調度（unscheduled）的 Pod，並選擇一個最佳節點來運行這些 Pod。由於 Pod 中的容器和 Pod 本身可能有不同的要求，調度程序會過濾掉任何不滿足 Pod 特定調度需求的節點。

kube-scheduler 的設計上允許你自己編寫一個調度組件並替換原有的 kube-scheduler。

以下是 kube-scheduler 的部分功能：

* 根據 Pod 的資源需求、節點的狀態和調度策略，選擇合適的節點來調度 Pod。
* 支持多種調度策略，包括預設調度策略、最小資源調度策略、優先調度策略和污點調度策略。
* 支持 Pod 的親和性和反親和性規範。

# 手動 scheduling

情境題: 手動scheduling

*重點:沒有 scheduler 時，需要手動在 YAML 裡頭設置要把 POD 哪個 Node 。*

建立一個 nginx

```
kubectl create -f nginx.yaml
```

nginx.yaml

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  -  image: nginx
     name: nginx
```

檢查狀態

```
controlplane ~ ✖ kubectl get pod
NAME    READY   STATUS    RESTARTS   AGE
nginx   0/1     Pending   0          69s
```

發現是 pending ，進一步檢查 kube-system 本身。

```
controlplane ~ ➜  kubectl get pods --namespace kube-system
NAME                                   READY   STATUS    RESTARTS   AGE
coredns-5d78c9869d-mdvgw               1/1     Running   0          38m
coredns-5d78c9869d-sft2h               1/1     Running   0          38m
etcd-controlplane                      1/1     Running   0          38m
kube-apiserver-controlplane            1/1     Running   0          38m
kube-controller-manager-controlplane   1/1     Running   0          38m
kube-proxy-57ftt                       1/1     Running   0          38m
kube-proxy-94x5r 
```

結果發現不存在 scheduler。

手動進行 scheduling。

先刪除掉失效的 pod。

```
kubectl delete pod nginx
```

檢查可用的 node

```
kubectl get nodes
```

發現 node01。

```
controlplane ~ ➜  kubectl get nodes
NAME           STATUS   ROLES           AGE   VERSION
controlplane   Ready    control-plane   45m   v1.27.0
node01         Ready    <none>          45m   v1.27.0
```

手動將 YAML 檔案中加入指定 node01 。

nginx.yaml

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  nodeName: node01
  containers:
  -  image: nginx
     name: nginx
```

建立 pod 。

```
kubectl create -f nginx.yaml
```

這樣就能建立成功了。

檢查一下是否正確放到特定 pod ，用 `-o wide` 可以顯示所在 pod 。

```
kubectl get pods -o wide
```

結果如下:

```
controlplane ~ ✖ kubectl get pods -o wide
NAME    READY   STATUS    RESTARTS   AGE   IP           NODE     NOMINATED NODE   READINESS GATES
nginx   1/1     Running   0          21s   10.244.1.2   node01   <none>           <none>
```

# Labels and Selectors

Labels 是附加到 Kubernetes 對象（例如 Pod、Deployment、Service 等）上的鍵值對。它們可以用來對對象進行分類和標識，以便於管理和查找。例如，您可以為所有屬於同一應用程序的 Pod 添加一個名為 “app” 的標籤，並為所有在生產環境中運行的 Pod 添加一個名為 “environment” 的標籤。

Selectors 是一種用於根據標籤過濾 Kubernetes 對象的表達式。它們可以用於在列表、命令和 API 調用中指定要包含或排除的對象。

選取特定 Label 的指令，例如此處的Label 為 `env` 其中數值為 `dev`:

```
kubectl get pods -l env=dev
```

或者

```
kubectl get pods --selector env=dev
```

如果要數某個 Label 有多少個可以用以下放是擴充指令。

```
kubectl get pods --selector env=dev --no-headers | wc -l
```

或者

```
kubectl get pods -l env=dev --no-headers | wc -l
```

如果要取得各種 Service, Pod, ReplicaSets 的話可以用以下指令

```
kubectl get all
```

取得所有物件時，也可以加註 Label，如下:

```
kubectl get all --selector env=prod
```

或者

```
kubectl get all -l env=prod
```

選擇多個標籤可以採用下列方法

```
kubectl get all --selector env=prod,bu=finance,tier=frontend
```

手動在 Node 添加 label 的方法

```
kubectl label node node01 color=blue
```

# Taints AND Tolerations

在 Kubernetes 中，Taints 和 Tolerations 是一種用於控制 Pod 調度到哪些節點上的機制。

### Taints

Taint 是一種附加到節點上的鍵值對。它表示該節點不適合運行具有特定容忍度（Toleration）的 Pod。例如，您可以為節點添加一個名為 “dedicated” 的 Taint，並將值設置為 “true”，表示該節點專用於運行特定應用程序的 Pod。

### Tolerations

Toleration 是一種附加到 Pod 上的鍵值對。它表示該 Pod 可以容忍特定 Taint。例如，您可以為 Pod 添加一個名為 “dedicated” 的 Toleration，並將值設置為 “true”，表示該 Pod 可以運行在具有 “dedicated” Taint 的節點上。

查看 Taint 的方法，就是用 describe 檢查某個 Node:

```
kubectl describe nodes node01
```

或者也可以用 grep 輔助。

```
kubectl describe nodes node01 |grep Taints
```

添加 Taints 的方法，將 node01 加上 spray=mortein 這個 taint ，並且效果為 NoSchedule (Pod 不可被調度到 Node 上)。

```
kubectl taint node node01 spray=mortein:NoSchedule
```

由於加了 taint 所以一般 Pod 無法放到該 Node ，除非加入 toleration。

添加 toleration 的方法如下:

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: bee
spec:
  containers:
  - image: nginx
    name: bee
  tolerations:
  - key: spray
    value: mortein
    effect: NoSchedule
    operator: Equal
```

如何移除掉 Taints 呢?

例如我們要移除`Taints:             node-role.kubernetes.io/control-plane:NoSchedule`，可採用以下指令:

```
kubectl taint node controlplane node-role.kubernetes.io/control-plane:NoSchedule-
```

也就是在 Taint 後方增加一個減號運算符號 `-` 。

移除 Taint 之後，原本無法調度的 Pod 會自動調度過去。

# Node Affinitty

在 Kubernetes 中，Node affinity（節點親和性）是一種用於控制 Pod 調度到哪些節點上的機制。它允許您根據節點的屬性和標籤，指定 Pod 應該调度到哪些節點上。

我們先用 `Label` 在 `node01` 上頭標記顏色 `color=blue`:

```
kubectl label node node01 color=blue
```

接著在 Deployment 的設置上設置 Node affinity:

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blue
spec:
  replicas: 3
  selector:
    matchLabels:
      run: nginx
  template:
    metadata:
      labels:
        run: nginx
    spec:
      containers:
      - image: nginx
        imagePullPolicy: Always
        name: nginx
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: color
                operator: In
                values:
                - blue
```

這個 pod 就會優先跑到有 color=blue 的 label 的 Node 上了。

### 關於強制調度，或者更傾向於調度

nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution

此屬性可強制將 Pod 調度到具有匹配標籤的節點上。如果沒有匹配標籤的節點，則 Pod 將無法調度。

nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution

此屬性僅使 Pod 更傾向於調度到具有匹配標籤的節點上。如果沒有匹配標籤的節點，Pod 仍會調度到其他節點。

